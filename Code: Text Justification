# -*- coding: utf-8 -*-

"""
After many, many failed attempts to incorporate a Justification button into my
Text Editor program, I restarted from scratch with an attempt to code ONLY the
font toolbar in "Skeleton for Font Styling". After many, many (MANY) more failed 
attempts to incorporate a function that would justify text so that would leave 
both sides of a paragraph flush into my font bar, this is a THIRD project that 
will souly focus on the Justify Text function.

Yes, I am that frustrated.

Once successful, this code will be incorporated into the font toolbar in 
"Skeleton for Font Styling", which will then be incorporated into my basic Text
Editor, and finally, into my Advanced Text Editor.

Bear with me.  I'm still learning.
"""

# Attempting to break on spaces and never in the middle of a word


import tkinter as tk

def get_text_widget_width(text_widget):
    return text_widget.winfo_width()

def justify_text(event):
    new_width = event.width
    text = text_widget.get("1.0", "end-1c")
    justified_text = justify_text_helper(text, new_width)
    text_widget.delete("1.0", "end")
    text_widget.insert("1.0", justified_text)

def justify_text_helper(text, width):
    words = split_words(text)  # Custom function to split text into words
    dp = [0] * len(words)  # Dynamic programming array to store the "badness" values
    breaks = [0] * len(words)  # Array to store the optimal break positions

    # Calculate the "badness" values for each line break position
    for i in range(len(words) - 1, -1, -1):
        min_badness = float('inf')
        line_width = 0
        for j in range(i, len(words)):
            if j > i:
                line_width += len(words[j]) + 1
            else:
                line_width += len(words[j])
            if line_width <= width:
                if len(words[j]) > width:  # If word is longer than line width
                    # Break word into multiple lines with hyphenation
                    hyphenated_word = hyphenate_word(words[j], width)
                    badness = (width - len(hyphenated_word)) ** 2
                else:
                    badness = (width - line_width) ** 2
                if j == len(words) - 1:
                    curr_badness = badness
                else:
                    curr_badness = badness + dp[j + 1]
                if curr_badness < min_badness:
                    min_badness = curr_badness
                    dp[i] = min_badness
                    breaks[i] = j

    # Reconstruct the justified text with optimal line breaks
    justified_lines = []
    i = 0
    while i < len(words):
        line = ' '.join(words[i:breaks[i] + 1])
        justified_lines.append(line)
        i = breaks[i] + 1

    justified_text = '\n'.join(justified_lines)
    return justified_text

def hyphenate_word(word, width):
    hyphenated_word = ''
    remaining_width = width
    for char in word:
        if remaining_width <= 0:
            hyphenated_word += '-\n' + char
            remaining_width = width - 1
        else:
            hyphenated_word += char
            remaining_width -= 1
    return hyphenated_word

def split_words(text):
    words = []
    word = ''
    for char in text:
        if char == ' ':
            if word:
                words.append(word)
                word = ''
        else:
            word += char
    if word:
        words.append(word)
    return words

# Example usage:
root = tk.Tk()

text_widget = tk.Text(root)
text_widget.pack(fill="both", expand=True)

text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."
text_widget.insert("1.0", text)

root.bind("<Configure>", justify_text)

root.mainloop()

