# -*- coding: utf-8 -*-

"""
After many, many failed attempts to incorporate a Justification button into my
Text Editor program, I restarted from scratch with an attempt to code ONLY the
font toolbar in "Skeleton for Font Styling". After many, many (MANY) more failed 
attempts to incorporate a function that would justify text so that would leave 
both sides of a paragraph flush into my font bar, this is a THIRD project that 
will souly focus on the Justify Text function.

Yes, I am that frustrated.

Once successful, this code will be incorporated into the font toolbar in 
"Skeleton for Font Styling", which will then be incorporated into my basic Text
Editor, and finally, into my Advanced Text Editor.

Bear with me.  I'm still learning.
"""


import tkinter as tk

def get_text_widget_width(text_widget):
    # Get the width of the text widget in pixels
    return text_widget.winfo_width()

def align_justify():
    # Get all ranges of selected text
    selections = text_widget.tag_ranges("sel")
    
    if not selections:
        # No text selected, do nothing
        return
    
    # Iterate over each selected range
    for i in range(0, len(selections), 2):
        start = selections[i]
        end = selections[i + 1]

        # Get the selected text
        text = text_widget.get(start, end)
        new_width = get_text_widget_width(text_widget) // 8  # Approximate character width in pixels
        justified_text = align_justify_helper(text, new_width)  # Justify the selected text

        # Replace the selected text with the justified text
        text_widget.delete(start, end)
        text_widget.insert(start, justified_text)

def align_justify_helper(text, width):
    # This function justifies the entire text while preserving paragraph breaks
    paragraphs = text.split('\n\n')  # Split text into paragraphs by double newline characters
    justified_paragraphs = []  # List to hold justified paragraphs
    
    for paragraph in paragraphs:
        # For each paragraph, justify its text
        lines = justify_paragraph(paragraph, width)
        justified_paragraphs.append('\n'.join(lines))  # Join the lines back into a single string for the paragraph
    
    justified_text = '\n\n'.join(justified_paragraphs)  # Join all paragraphs with double newline characters
    return justified_text

def justify_paragraph(paragraph, width):
    # This function justifies a single paragraph
    words = paragraph.split()  # Split paragraph into individual words
    lines = []  # List to hold the lines of the paragraph
    current_line = []  # List to hold the words of the current line
    current_length = 0  # Length of the current line
    
    for word in words:
        # Check if adding the word would exceed the width
        if current_length + len(word) + len(current_line) > width:
            lines.append(current_line)  # Add the current line to the list of lines
            current_line = [word]  # Start a new line with the current word
            current_length = len(word)  # Reset the length of the current line
        else:
            # Add the word to the current line
            current_line.append(word)
            current_length += len(word)  # Update the length of the current line
    
    if current_line:
        # Add the last line to the list of lines
        lines.append(current_line)
    
    justified_lines = []  # List to hold the justified lines
    for line in lines[:-1]:  # Justify all lines except the last one
        line_length = sum(len(word) for word in line) + 1  # Calculate the total length of words in the line
        # +1 Necessary for smooth screen re-sizings !!!
        total_spaces = width - line_length  # Calculate the total number of spaces needed to justify the line
        gaps = len(line) - 1  # Number of gaps between words
        if gaps > 0:
            spaces = total_spaces // gaps  # Minimum spaces to add between each word
            extra_spaces = total_spaces % gaps  # Extra spaces to distribute evenly
            justified_line = ''  # String to hold the justified line
            for i, word in enumerate(line):
                # Add the word to the justified line
                justified_line += word
                if i < gaps:
                    # Add spaces after the word if it's not the last word in the line
                    justified_line += ' ' * (spaces + 1 if i < extra_spaces else spaces)
            justified_lines.append(justified_line)  # Add the justified line to the list
        else:
            # If there's only one word in the line, add it as is
            if line:  # Check if line is not empty
                justified_lines.append(line[0])

    # Add the last line without justification
    last_line = ' '.join(lines[-1])
    justified_lines.append(last_line)
    
    return justified_lines

def justify_all_text(event=None):
    # Get the entire content of the text widget
    text = text_widget.get("1.0", "end-1c")
    new_width = get_text_widget_width(text_widget) // 8  # Approximate character width in pixels
    justified_text = align_justify_helper(text, new_width)  # Justify the entire text

    # Replace the entire content with the justified text
    text_widget.delete("1.0", "end")
    text_widget.insert("1.0", justified_text)

# Example usage:
root = tk.Tk()  # Create the main window

text_widget = tk.Text(root)  # Create a text widget
text_widget.pack(fill="both", expand=True)  # Make the text widget fill the window

# Sample text to insert into the text widget
text = (
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\n\n"
    "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."
)
text_widget.insert("1.0", text)  # Insert the sample text into the text widget

# Create a button to justify the selected text
justify_button = tk.Button(root, text="Justify Selected Text", command=align_justify)
justify_button.pack()

# Bind the configure event to justify all text when the window is resized
root.bind("<Configure>", justify_all_text)

root.mainloop()  # Start the Tkinter event loop

