# -*- coding: utf-8 -*-

"""
After many, many failed attempts to incorporate a Justification button into my
Text Editor program, I restarted from scratch with an attempt to code ONLY the
font toolbar in "Skeleton for Font Styling". After many, many (MANY) more failed 
attempts to incorporate a function that would justify text so that would leave 
both sides of a paragraph flush into my font bar, this is a THIRD project that 
will souly focus on the Justify Text function.

Yes, I am that frustrated.

Once successful, this code will be incorporated into the font toolbar in 
"Skeleton for Font Styling", which will then be incorporated into my basic Text
Editor, and finally, into my Advanced Text Editor.

Bear with me.  I'm still learning.
"""


# Works!  Preserves font attributes when font alignment is changed
# Next up: Interface got re-arranged


from PIL import Image, ImageTk  # For buttons on Toolbar
import tkinter as tk
from tkinter import font
from tkinter import colorchooser
from tkinter import ttk

# Set default font
global default_font
default_font = "Arial"
global default_size
default_size = 12

current_font_family = default_font
current_font_size = default_size

global current_tags
current_tags = []
global style_counter  # Serialize the Styles of Font to Create Unique Tags
style_counter = 0

# MAIN MENU METHODS

# FORMAT BAR METHODS

# COMBOBOX METHODS

def apply_font_style(event=None, fontColor=None, fontBackground=None):
    global current_font_family
    global current_font_size    
    global style_counter
    global last_selection

    # Check if any text is selected
    if text_widget.tag_ranges("sel"):
        # Get the tags applied to the selected text
        current_tags = text_widget.tag_names("sel.first")

        # Determine font weight, slant, underline, and overstrike
        weight = "bold" if "bold" in current_tags else "normal"
        slant = "italic" if "italic" in current_tags else "roman"
        underline = 1 if "underline" in current_tags else 0
        overstrike = 1 if "overstrike" in current_tags else 0

        # Generate a unique tag for the selected text
        tag_name = "custom_font_{}".format(style_counter)

        # Increment style_counter for next font style
        style_counter += 1        
        
        # Apply font styling to the selected text
        text_widget.tag_add(tag_name, "sel.first", "sel.last")

        # Configure the tag with the desired font and style attributes
        text_widget.tag_configure(tag_name, font=(current_font_family, current_font_size, weight, slant),
                           underline=underline, overstrike=overstrike,
                           foreground=fontColor, background=fontBackground)

    else:
        # Alert the user that no text has been selected
        tk.messagebox.showinfo("alert", "No text has been selected")


def update_comboboxes(event):
    # Get the index of the clicked position    
    cursor_position = text_widget.index("@{},{}".format(event.x, event.y))

    # Get the tag names associated with the cursor position    
    tags = text_widget.tag_names(cursor_position)
    
    # Check if the font attribute is not empty and contains the font family
    if tags:
        # Iterate through tags to find the font attributes
        for tag in tags:
            if tag.startswith("custom_font_"):
                font_info = text_widget.tag_cget(tag, "font")

                family = font.Font(font=font_info).actual()["family"]
                size = font.Font(font=font_info).actual()["size"]

                font_family_combo.set(family)
                font_size_combo.set(size)

    else:
        # Set the font and size comboboxes to display the default font and size
        font_family_combo.set(default_font)
        font_size_combo.set(default_size)

def update_font(event=None):
    global current_font_family
    global current_font_size
    global style_counter

    selected_font = font.Font(family=font_family_combo.get(), size=int(font_size_combo.get()))
    text_widget.tag_configure("custom_font_{}".format(style_counter), font=selected_font)
    
    # Get the selected font family and size
    current_font_family = font_family_combo.get()
    current_font_size = font_size_combo.get()

    # Apply font styling to the selected text
    apply_font_style()


# BUTTON METHODS
# Bold Text bold_it()
def bold(event=None):        
    # Check if any text is selected, otherwise app throws an error
    if text_widget.tag_ranges("sel"):
        # Define Current tags
        current_tags = list(text_widget.tag_names())

        # Check to see if tag has already been set
        if "bold" in current_tags:
            # If characters are bold, unbold the range  
            text_widget.tag_delete("bold", "sel.first", "sel.last")
        else:
            # Bold the whole selection
            text_widget.tag_add("bold", "sel.first", "sel.last")
    
        # Compile stle characteristics under a single tag name
        apply_font_style()
    else:
        # Alert user that no text has been selected
        tk.messagebox.showinfo("alert", "No text has been selected")

# Italics Text italics_it()
def italic(event=None):
    # Check if any text is selected, otherwise app throws an error
    if text_widget.tag_ranges("sel"):
        # Define Current tags
        current_tags = list(text_widget.tag_names())

        # Check to see if tag has already been set
        if "italic" in current_tags:
            # If characters are italicized, unitalicize the selected text
            text_widget.tag_add("roman", "sel.first", "sel.last")
            text_widget.tag_delete("italic", "sel.first", "sel.last")
        else:
            # Italicize the whole selection
            text_widget.tag_add("italic", "sel.first", "sel.last")
    
        # Compile stle characteristics under a single tag name
        apply_font_style()
    else:
        # Alert user that no text has been selected
        tk.messagebox.showinfo("alert", "No text has been selected")
        
# Underline Text underline_it():
def underline(event=None):
    # Check if any text is selected, otherwise app throws an error
    if text_widget.tag_ranges("sel"):
        # Define Current tags
        current_tags = list(text_widget.tag_names())

        # Check to see if tag has already been set
        if "underline" in current_tags:
            # If characters are underlined, remove underlining from the selected text
            text_widget.tag_delete("underline", "sel.first", "sel.last")
        else:
            # Underline the whole selection
            text_widget.tag_add("underline", "sel.first", "sel.last")

        # Compile stle characteristics under a single tag name
        apply_font_style()
    else:
        # Alert user that no text has been selected
        tk.messagebox.showinfo("alert", "No text has been selected")

# Strike Text strike_it()
def strike(event=None):
    # Check if any text is selected, otherwise app throws an error
    if text_widget.tag_ranges("sel"):
        # Define Current tags        									
        current_tags = list(text_widget.tag_names())

        # Check to see if tag has already been set												  
        if "overstrike" in current_tags:
            # If characters are striked, remove striking from the selected text
            text_widget.tag_delete("overstrike", "sel.first", "sel.last")	
        else:
            # Strike the whole selection
            text_widget.tag_add("overstrike", "sel.first", "sel.last")
    
        # Compile stle characteristics under a single tag name
        apply_font_style()    
    else:
        # Alert user that no text has been selected
        tk.messagebox.showinfo("alert", "No text has been selected")

# Change Font Color from Default
def change_color(event=None):
    # Ask the user to choose a font color
    color = colorchooser.askcolor(initialcolor="#000000", title="Choose Font Color")
    color_name = color[1]
    
    # Don't have to remove tag for fontColor the way I do for tags like bold
    
    # Check if any text is selected
    if text_widget.tag_ranges("sel"):
        # Call apply_font_style with updated fontColor
        apply_font_style(fontColor=color_name)
    else:
        # Alert the user that no text has been selected  
        tk.messagebox.showinfo("alert", "No text has been selected")

# Highlight 
def highlight(event=None):
    # Ask the user to choose a background color    
    color = colorchooser.askcolor(initialcolor="#FFFF00", title="Choose Highlight Color")
    color_rgb = color[1]

    # Don't have to remove tag for fontBackground the way I do for tags like bold

    # Check if any text is selected
    if text_widget.tag_ranges("sel"):
        # Call apply_font_style with updated fontBackground
        apply_font_style(fontBackground=color_rgb)
    else:
        # Alert the user that no text has been selected  
        tk.messagebox.showinfo("alert", "No text has been selected")


def remove_align_tags(start=None, end=None):
    if start is None or end is None:
        # Get the start and end of the entire text widget
        start = "1.0"
        end = "end"

    all_tags = text_widget.tag_names(start)

    if "center" in all_tags:
        text_widget.tag_remove("center", start, end)
    if "left" in all_tags:
        text_widget.tag_remove("left", start, end)
    if "right" in all_tags:
        text_widget.tag_remove("right", start, end)
    if "justified" in all_tags:
        text_widget.tag_remove("justified", start, end)

def get_current_font_tags(start):
    tags = text_widget.tag_names(start)
    font_tags = {}

    for tag in tags:
        if tag.startswith("custom_font_"):
            font_tags["font"] = text_widget.tag_cget(tag, "font")
        if text_widget.tag_cget(tag, "foreground"):
            font_tags["foreground"] = text_widget.tag_cget(tag, "foreground")
        if text_widget.tag_cget(tag, "background"):
            font_tags["background"] = text_widget.tag_cget(tag, "background")
        if text_widget.tag_cget(tag, "underline"):
            font_tags["underline"] = text_widget.tag_cget(tag, "underline")
        if text_widget.tag_cget(tag, "overstrike"):
            font_tags["overstrike"] = text_widget.tag_cget(tag, "overstrike")

    return font_tags

def apply_font_tags(font_tags, tag_name):
    if "font" in font_tags:
        text_widget.tag_configure(tag_name, font=font_tags["font"])
    if "foreground" in font_tags:
        text_widget.tag_configure(tag_name, foreground=font_tags["foreground"])
    if "background" in font_tags:
        text_widget.tag_configure(tag_name, background=font_tags["background"])
    if "underline" in font_tags:
        text_widget.tag_configure(tag_name, underline=font_tags["underline"])
    if "overstrike" in font_tags:
        text_widget.tag_configure(tag_name, overstrike=font_tags["overstrike"])

# Align Center Text center_it():
def align_center(event=None):
    # Check if any text is selected
    if text_widget.tag_ranges("sel"):
        # Align entire selection
        start_index = text_widget.index("sel.first")
        end_index = text_widget.index("sel.last")

        # Get current font tags to preserve them
        current_font_tags = get_current_font_tags(start_index)

        # Remove existing alignment tags within the range
        remove_align_tags(start_index, end_index)

        # Apply new alignment tags
        text_widget.tag_add("center", start_index, end_index)
        text_widget.tag_configure("center", justify="center")

        # Reapply preserved font tags
        apply_font_tags(current_font_tags, "center")
    else:
        # Alert the user that no text has been selected
        tk.messagebox.showinfo("alert", "No text has been selected")

# Align Left Text align_left()
def align_left(event=None):
    # Check if any text is selected
    if text_widget.tag_ranges("sel"):
        # Align entire selection
        start_index = text_widget.index("sel.first")
        end_index = text_widget.index("sel.last")

        # Get current font tags to preserve them
        current_font_tags = get_current_font_tags(start_index)

        # Remove existing alignment tags within the range
        remove_align_tags(start_index, end_index)

        # Apply new alignment tags
        text_widget.tag_add("left", start_index, end_index)
        text_widget.tag_configure("left", justify="left")

        # Reapply preserved font tags
        apply_font_tags(current_font_tags, "left")
    else:
        # Alert the user that no text has been selected
        tk.messagebox.showinfo("alert", "No text has been selected")

# Align Right Text align_right()
def align_right(event=None):
    # Check if any text is selected
    if text_widget.tag_ranges("sel"):
        # Align entire selection
        start_index = text_widget.index("sel.first")
        end_index = text_widget.index("sel.last")

        # Get current font tags to preserve them
        current_font_tags = get_current_font_tags(start_index)

        # Remove existing alignment tags within the range
        remove_align_tags(start_index, end_index)

        # Apply new alignment tags
        text_widget.tag_add("right", start_index, end_index)
        text_widget.tag_configure("right", justify="right")

        # Reapply preserved font tags
        apply_font_tags(current_font_tags, "right")
    else:
        # Alert the user that no text has been selected
        tk.messagebox.showinfo("alert", "No text has been selected")

# Align Justify Text align_justify()
def align_justify(event=None):
    # Check if any text is selected
    if text_widget.tag_ranges("sel"):
        # Align entire selection
        start_index = text_widget.index("sel.first")
        end_index = text_widget.index("sel.last")

        # Get current font tags to preserve them
        current_font_tags = get_current_font_tags(start_index)

        # Remove existing alignment tags within the range
        remove_align_tags(start_index, end_index)

        # Apply new alignment tags
        text_widget.tag_add("justified", start_index, end_index)
        text_widget.tag_configure("justified", justify="left")

        # Reapply preserved font tags
        apply_font_tags(current_font_tags, "justified")
    else:
        # Alert the user that no text has been selected
        tk.messagebox.showinfo("alert", "No text has been selected")
        

# Change Font
def change_font(event):
    # Get the selected font family and size
    selected_font_family = font_family_combo.get()
    selected_font_size = int(font_size_combo.get())
    
    # Apply the selected font to the entire text widget
    text_widget.tag_configure("custom_font", font=(selected_font_family, selected_font_size))
    
    # Get the start and end index of the selected text
    start_index = text_widget.index("sel.first")
    end_index = text_widget.index("sel.last")
    
    # Apply the custom font tag to the selected text
    text_widget.tag_add("custom_font", start_index, end_index)
    text_widget.tag_configure("custom_font", font=(selected_font_family, selected_font_size))

    # Update the font family and size variables
    global current_font_family
    global current_font_size
    current_font_family = selected_font_family
    current_font_size = selected_font_size

# Other Functions
def select_all(event):
    text_widget.tag_add("sel", "1.0", "end")

def deselect_all(event):
    text_widget.tag_remove("sel", "1.0", "end")

# MAIN APPLICATION

root = tk.Tk()
root.title("Word Processor Clone")
root.geometry("1200x800")

# Create a main frame
main_frame = tk.Frame(root)
main_frame.pack(fill=tk.BOTH, expand=1)

# Create a text widget
text_widget = tk.Text(main_frame, wrap=tk.WORD, font=(default_font, default_size), undo=True)
text_widget.pack(fill=tk.BOTH, expand=1)

# Add scrollbars to the text widget
scrollbar = tk.Scrollbar(text_widget)
scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
text_widget.config(yscrollcommand=scrollbar.set)
scrollbar.config(command=text_widget.yview)

# Set a default font for the text widget
default_font = font.Font(family="Arial", size=12)
text_widget.configure(font=default_font)

# Add combobox for font family
font_families = list(font.families())
font_family_combo = ttk.Combobox(main_frame, values=font_families, state="readonly")
font_family_combo.set(default_font.actual()["family"])
font_family_combo.pack(side=tk.LEFT, padx=10)
font_family_combo.bind("<<ComboboxSelected>>", update_font)

# Add combobox for font size
font_sizes = list(range(8, 73, 2))
font_size_combo = ttk.Combobox(main_frame, values=font_sizes, state="readonly")
font_size_combo.set(default_font.actual()["size"])
font_size_combo.pack(side=tk.LEFT)
font_size_combo.bind("<<ComboboxSelected>>", update_font)

# Create a toolbar frame
toolbar_frame = tk.Frame(main_frame)
toolbar_frame.pack(fill=tk.X)

# Add toolbar buttons for text alignment
align_left_button = tk.Button(toolbar_frame, text="Align Left", command=align_left)
align_left_button.pack(side=tk.LEFT, padx=2)
align_center_button = tk.Button(toolbar_frame, text="Align Center", command=align_center)
align_center_button.pack(side=tk.LEFT, padx=2)
align_right_button = tk.Button(toolbar_frame, text="Align Right", command=align_right)
align_right_button.pack(side=tk.LEFT, padx=2)
align_justify_button = tk.Button(toolbar_frame, text="Justify", command=align_justify)
align_justify_button.pack(side=tk.LEFT, padx=2)

# Bind events for selecting all and deselecting all text
root.bind_all("<Control-a>", select_all)
root.bind_all("<Control-Shift-a>", deselect_all)

# Bind event for updating comboboxes when clicking in the text widget
text_widget.bind("<Button-1>", update_comboboxes)

root.mainloop()

