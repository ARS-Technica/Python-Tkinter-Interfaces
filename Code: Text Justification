# -*- coding: utf-8 -*-

"""
After many, many failed attempts to incorporate a Justification button into my
Text Editor program, I restarted from scratch with an attempt to code ONLY the
font toolbar in "Skeleton for Font Styling". After many, many (MANY) more failed 
attempts to incorporate a function that would justify text so that would leave 
both sides of a paragraph flush into my font bar, this is a THIRD project that 
will souly focus on the Justify Text function.

Yes, I am that frustrated.

Once successful, this code will be incorporated into the font toolbar in 
"Skeleton for Font Styling", which will then be incorporated into my basic Text
Editor, and finally, into my Advanced Text Editor.

Bear with me.  I'm still learning.
"""

# Works beautifully when text is pasted in.  Fails when window resizes.


import tkinter as tk

def get_text_widget_width(text_widget):
    return text_widget.winfo_width()


def justify_text(event):
  new_width = event.width // 10  # Adjusting for character width in pixels
  text = text_widget.get("1.0", "end-1c")
  justified_text = justify_text_helper(text, new_width)
  text_widget.delete("1.0", "end")
  text_widget.insert("1.0", justified_text)


def justify_text_helper(text, width):  # 'width' argument not used in this function

  words = text.split()
  lines = []
  current_line = []
  left_justify = True  # Flag to control justification mode (default: left)

  def add_line():
    if not current_line:
      return
    line = ' '.join(current_line)
    # Access available_width from the enclosing scope (likely justify_text function)
    available_width = justify_text.available_width  # Assuming 'available_width' is defined in justify_text

    # Left Justification Logic
    if left_justify:
      spaces_to_add = available_width - len(line)
      if spaces_to_add > 0:
        line += ' ' * spaces_to_add

    # Right Justification Logic
    else:
      spaces_to_add = available_width - len(line)
      if spaces_to_add > 0:
        # (Your existing justification logic using 'available_width' and 'spaces_to_add')
        # Consider using floor division and potentially different space distribution for right justification
        extra_spaces = spaces_to_add // available_width  # Use floor division
        spaces_per_gap = extra_spaces + 1
        line = (' ' * spaces_per_gap).join(current_line)
        # Distribute remaining spaces (if any)
        for i in range(spaces_to_add % available_width):
          line = line[:i * (extra_spaces + 1) + i] + ' ' + line[i * (extra_spaces + 1) + i:]

    lines.append(line)
    current_line.clear()

    # Hyphenation Logic (Optional)
    # Integrate your existing hyphenation logic here, considering:
    # - Checking for available space before hyphenation
    # - Adjusting space distribution for hyphenated words
  
    for word in words:
      if len(' '.join(current_line + [word])) > available_width:
        add_line()
      current_line.append(word)
    
    add_line()  # Add the last line
  
    return '\n'.join(lines)


# In your justify_text function (or similar):
def justify_text(event):  # Assuming triggered by a resize event
  new_width = event.width // 10  # Adjusting for character width in pixels
  text = text_widget.get("1.0", "end-1c")
  justified_text = justify_text_helper(text, new_width)  # Pass new_width to justify_text_helper
  text_widget.delete("1.0", "end")
  text_widget.insert("1.0", justified_text)
  # Update available_width for justification_helper to access
  justify_text.available_width = new_width  # Assuming 'available_width' is a variable within justify_text


# Example usage:
root = tk.Tk()

text_widget = tk.Text(root)
text_widget.pack(fill="both", expand=True)

text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."
text_widget.insert("1.0", text)

root.bind("<Configure>", justify_text)

root.mainloop()

