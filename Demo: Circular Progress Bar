"""
Circular Progress Bar

The challenge is to create a circular progress gauge that counts up from 0 to 
100 in Python using the Tkinter library.  Every example of Circular Progress 
Bars I could find on Youtube made use of Pyside or PyQT.  I'm currently teaching
myself Tkinter, and I'm interested in seeing if the same effect can be 
established with plain vanilla Tkinter and some math.
"""

from tkinter import Button, Canvas, Frame, Tk, ttk
from math import cos, radians, sin   # For drawing circles (Thanx Stack Overflow)

def create_interface():
    global canvas, degrees, scale, window
from tkinter import Button, Canvas, Frame, Tk, ttk
from math import cos, radians, sin   # For drawing circles (Thanx Stack Overflow)

def create_interface():
    global canvas, degrees, scale, window

    degrees = 0  # Will be divided into percentage in update_progress_gauge

    window = create_window()
    canvas, scale = create_progress_gauge(window)
    scale.bind("<Motion>", lambda event: update_progress_gauge())  # Bind scale movement to update function
    update_progress_gauge()

    window.mainloop()

def create_progress_gauge(window):
    frame = Frame(window, height=600, width=600, bg="black", relief="sunken")
    frame.grid(columnspan=2, row=0)

    canvas = Canvas(frame, bg="black", width=585, height=585, relief="raised", bd=1)
    canvas.grid(padx=5, pady=5)
    
    scale = ttk.Scale(window, orient="horizontal", style="Horizontal.TScale", from_=0, to=360, length=400)
    scale.set(0)
    scale.grid(column=1, row=1, pady=10, padx=5)

    style = ttk.Style()
    style.configure("Horizontal.TScale", background="black")

    Button(window, text="Start", bg="green2", width=20, command=update_progress_gauge).grid(column=0, row=1, padx=3, pady=5)
    scale.grid(column=1, row=1, pady=10, padx=5)
    
    # Draw the circular outlines of the gauge
    canvas.create_oval(100, 100, 500, 500, fill="", outline="", width=5, tag="outline")
    canvas.create_oval(150, 150, 450, 450, fill="", outline="dark violet", width=6, tag="outline")
    canvas.create_oval(180, 180, 420, 420, fill="black", outline="dark violet", width=6, tag="outline")
    canvas.tag_raise('outline')
        
    return canvas, scale

def create_window():   
    window = Tk()
    window.title("Demo: Circular Progress Gauge")
    window.geometry("600x650+100+100")
    window.configure(bg="#000000")
    # Hide the title bar
    # window.overrideredirect(True)

    return window

def update_progress_gauge():
    global canvas, degrees, window

    #degrees = int(scale.get())													 
    new_degrees = int(scale.get())  # In case scale moves backwards

    # Check if the progress has crossed the 360 degree mark (100%)
    if degrees >= 360 and new_degrees < 360:    # 360 degrees = 100%
        canvas.delete("progress_text_complete")
        canvas.create_text(300, 325, text="PROGRESS", font=("Arial", 22, "bold"), fill="white", tags="progress_text")

    degrees = new_degrees						
											 				
    #canvas.delete("progress_lines") # NO.  Not if you want gauge to fill in
    canvas.delete("progress_text")  # Prevent text updates from piling up
  
    # Draw progress lines
    canvas.create_line(300, 300, 300 + 150 * sin(radians(degrees)),
                       300 - 150 * cos(radians(degrees)),
                       fill="deep sky blue", width=20, tags="progress_lines")

    # Display progress text
    progress_text = f"{int(degrees / 3.6)}%"
    canvas.create_text(300, 275, text=progress_text, font=("Arial", 42, "bold"), fill="deep sky blue", tags="progress_text")

    # Announce countdown is complete at 360 degrees (100%) and update the text accordingly 
    if degrees >= 360: 		# 360 degrees = 100%												  
        canvas.create_text(300, 325, text="COMPLETE!", font=("Arial", 22, "bold"), fill="white", tags="progress_text_complete")
    else:
        canvas.create_text(300, 325, text="PROGRESS", font=("Arial", 22, "bold"), fill="white", tags="progress_text")

    canvas.tag_lower("progress_lines")
    window.after(20, update_progress_gauge)    # Adjust the delay time as needed
    # Note: Delays of 50 or over may result is gaps opening up in the ring
    # Note: Delays of less than 20 may result in the application freezing up
 
if __name__ == "__main__":
    create_interface()

